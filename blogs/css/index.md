---
title: css基础知识
date: 2023-03-17
categories:
 - css
---

:::tip
本节内容主要介绍一些基础知识，或者容易忽视或混淆的点
:::

## 选择器

### 选择器优先级

:::tip

>一个选择器的优先级可以说是由三个不同的值（或分量）相加，可以认为是百（ID）十（类）个（元素）——三位数的三个位数：
>
>ID：选择器中包含 ID 选择器则百位得一分。
>类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。
>元素：选择器中包含元素、伪元素选择器则个位得一分。


*备注： 通用选择器（\*）、组合符（+、>、~、' '）和调整优先级的选择器（:where()）不会影响优先级。*

*否定（:not()）和任意匹配（:is()）伪类本身对优先级没有影响，但它们的参数则会带来影响。参数中，对优先级算法有贡献的参数的优先级的**最大值**将作为该伪类选择器的优先级*



| 选择器 | ID | 类 |元素|优先级|
|---|---|---|---|---|
|h1	|0	|0|	1	|0-0-1|
|h1 + p::first-letter|	0	|0	|3	|0-0-3|
|li > a[href*="en-US"] > .inline-warning|	0	|2	|2	|0-2-2|
|#identifier|	1|	0|	0	|1-0-0|
|button:not(#mainBtn, .cta)	|1	|0	|1	|1-0-1|

上述示例中 `button:not(#mainBtn, .cta)`之所以权重是是100 + 10 是因为not选择器只会根据传入参数的最大权重作为伪类选择器的优先级，因此实际权重是`button一个元素 + #mainBtn一个ID`
:::

覆盖声明的顺序
相互冲突的声明将按以下顺序应用，后一种声明将覆盖前一种声明：

用户代理样式表中的声明（例如，浏览器的默认样式，在没有设置其他样式时使用）。
用户样式表中的常规声明（由用户设置的自定义样式，比如浏览器提供的，允许用户更改字体大小等基本样式）。
作者样式表中的常规声明（这些是我们 web 开发人员设置的样式）。
作者样式表中的 !important 声明
用户样式表中的 !important 声明
用户代理样式表中的 !important 声明

:::tip
!important > 内联样式的权重 > 其他类型样式，无论有多少个ID选择器

所谓用户自定义样式指用户通过浏览器设置并改变的样式，目前只在浏览器找到一些字体相关的设置，至于其他复杂设置不同浏览器不同，早期的chrome和IE是允许提供一个custom.css去指定样式的。后面都取消了，旨在尽可能尊重开发者的设计
:::






### 全局选择器 *
除了常见的全局写法，还有子节点的全部选择，比如

```css
/**html下所有元素都会被选中 */
* {
  margin: 0;
}
/**div 下所有标签都会被选中 */
div * {

}


/**div下，所有第一个子元素都会被选中*/
div *:first-child{ /**等同于  div :first-child（中间有空格，表示div下的子元素） */

}

/**div 下所有不同类型元素 的第一个元素，比如div下有p和a标签，则所有p标签的第一个p标签，和所有a标签下的第一个a标签都匹配成功 */
div *:first-of-type {}


```

## 伪元素和伪类

### :first-child和:first-of-type

这两个伪元素很容易混淆，实际上都是有迹可循，`:first-child`表示指定选择器对象是其父节点的第一个子元素，`:first-of-type`表示指定选择器对象，是其父节点下（同一类对象的第一个子元素）

举例：

```html
<div>
<a>a1</a>
<a>a2</a>
<p>p1</p>
<p>p2</p>
</div>
```

```css
/**:first-child 指定了 div下的p标签是其所有兄弟元素中的第一个，div下第一个子元素是a1(也就是p的兄弟元素中的第一个)，
因此该规则没有匹配成功，不会有变化 */
div p:first-child {
  background:red;
}

/**指定 div下 p元素的第一个元素，即所有p元素中排第一个的元素，因此p1内容会被匹配上 */
div p:first-of-type {
  background:red;
}

```

## 浮动

所有的元素都可以浮动，只需要增加`float`样式，浮动的特点是，被设置浮动的元素，会脱离常规文档流，直到碰到其他浮动元素或者父容器的内容边为止。

### 浮动的影响
由于浮动元素脱离了常规文档流，所以其他元素会占据其原来的位置，但是内容区域会被浮动元素挡在外面。这是浮动元素的特性（典型文字围绕图像），如果要清除浮动元素对后续元素产生的影响，则需要使用clearfix技巧

### 清除浮动

下面一个html结构将用来介绍如何清除浮动

```html
<style type="text/css">
.float{
  width: 50px;
  height: 50px;
}

</style>
<div class="wrapper">
<div class="float">浮动块</div> 
<p>我是紧随其后的P标签，文本块</p>
</div>
<div class="wrapper-after">我是wrapper后面的块</div>
```

 #### `clear`清除浮动

 >假设class为`.float`的块浮动起来了，则它脱离常规文档流，不占据高度，因此`P`标签会占据原来位置，且`P`标签的内容被`.float`块挤到`.float`外面。
 而且因为`float`脱离常规文档流，导致`.wrapper`块的高度由`P`标签撑开，即高度等于P标签高度，因此`.wrapper-after`也会跟着上移，这就是浮动的影响。

clear属性能够赋予某个元素清除浮动对后续元素的影响，我们只需要给不希望被浮动元素影响原来布局的元素，加上clear属性即可，详细参数查看MDN

#### `.wrapper`块添加伪元素::after 清除wrapper块以外的浮动

```css
.wrapper::after{
content: "";
display:block;
clear: both;
}
```
这种方式可以清除wrapper块相邻元素的浮动影响，并不能清除内部影响


#### `overflow为非visible`

可是使用`overflow`设置成非visible以外的属性，可以使`.wrapper`块生成BFC，这样能正确计算wrapper内容的高度，使得对wrapper外的元素没有影响，但是内部内容还是会被影响

#### `display: flow-root`

可以给`.wrapper`设置这个属性，相当于overflow的优化方案，对wrapper内部的元素还是有影响，只是清楚了外部浮动的影响

## 盒子模型

## 水平布局

## flex布局

## grid布局