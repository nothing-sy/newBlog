---
title: 排序算法
date: 2023-11-14
categories:
 - 算法
 - 排序算法
---

## 选择排序

### 思路

1. 初始状态下，所有元素未排序，即未排序（索引）区间为 [0,n-1]。
2. 选取区间 [0,n-1]中的最小元素，将其与索引 0处元素交换。完成后，数组前 1 个元素已排序。
3. 选取区间 [1,n-1]中的最小元素，将其与索引 1 处元素交换。完成后，数组前 2 个元素已排序。
4. 以此类推。经过 n-1 轮选择与交换后，数组前 n-1 个元素已排序。
5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。

> 记住选择排序只有在选择区间找到最小值以后才会置换元素（即在外层循环置换），而不是每次内循环都置换


### 代码实现

```js
/* 选择排序 */
function selectionSort(arr) {
 const len = arr.length;
 for (let i = 0; i < len - 1; i++) {
   let minIndex = i;
   for (let j = i + 1; j < len; j++) {
     if (arr[j] < arr[minIndex]) {
       minIndex = j;
     }
   }
   [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
 }
 return arr;
}

// 示例
const arr = [64, 34, 25, 12, 22, 11, 90];
const sortedArr = selectionSort(arr);
console.log("排序后的数组：", sortedArr);
```


## 冒泡排序

### 思路

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

### 代码实现

```js
function bubbleSort(arr) {
  const len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
}


```